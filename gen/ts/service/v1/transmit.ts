// @generated by protobuf-ts 2.8.1 with parameter generate_dependencies,long_type_string
// @generated from protobuf file "service/v1/transmit.proto" (package "sonrio.motor.service.v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Peer } from "../../common/v1/info";
/**
 * Standard MIME with Additional Extensions
 *
 * @generated from protobuf message sonrio.motor.service.v1.MIME
 */
export interface MIME {
    /**
     * Type of File
     *
     * @generated from protobuf field: sonrio.motor.service.v1.MIME.Type type = 1;
     */
    type: MIME_Type;
    /**
     * Extension of File
     *
     * @generated from protobuf field: string subtype = 2;
     */
    subtype: string;
    /**
     * Type/Subtype i.e. (image/jpeg)
     *
     * @generated from protobuf field: string value = 3;
     */
    value: string;
}
/**
 * File Content Type
 *
 * @generated from protobuf enum sonrio.motor.service.v1.MIME.Type
 */
export enum MIME_Type {
    /**
     * Other File Type - If cannot derive from Subtype
     *
     * @generated from protobuf enum value: TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Sound, Audio Files
     *
     * @generated from protobuf enum value: TYPE_AUDIO = 1;
     */
    AUDIO = 1,
    /**
     * Document Files - PDF, Word, Excel, etc.
     *
     * @generated from protobuf enum value: TYPE_DOCUMENT = 2;
     */
    DOCUMENT = 2,
    /**
     * Image Files
     *
     * @generated from protobuf enum value: TYPE_IMAGE = 3;
     */
    IMAGE = 3,
    /**
     * Text Based Files
     *
     * @generated from protobuf enum value: TYPE_TEXT = 4;
     */
    TEXT = 4,
    /**
     * Video Files
     *
     * @generated from protobuf enum value: TYPE_VIDEO = 5;
     */
    VIDEO = 5,
    /**
     * URL Links
     *
     * @generated from protobuf enum value: TYPE_URL = 6;
     */
    URL = 6,
    /**
     * Crypto Files
     *
     * @generated from protobuf enum value: TYPE_CRYPTO = 7;
     */
    CRYPTO = 7
}
/**
 * For Transfer File Payload
 *
 * @generated from protobuf message sonrio.motor.service.v1.FileItem
 */
export interface FileItem {
    /**
     * @generated from protobuf field: sonrio.motor.service.v1.MIME mime = 1;
     */
    mime?: MIME; // Standard Mime Type
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string; // File Name without Path
    /**
     * @generated from protobuf field: string path = 3;
     */
    path: string; // File Location
    /**
     * @generated from protobuf field: int64 size = 4;
     */
    size: string; // File Size in Bytes
    /**
     * @generated from protobuf field: sonrio.motor.service.v1.Thumbnail thumbnail = 5;
     */
    thumbnail?: Thumbnail; // Thumbnail of File
    /**
     * @generated from protobuf field: int64 last_modified = 6;
     */
    lastModified: string; // Last Modified Time in Seconds
}
/**
 * Payload is Data thats being Passed
 *
 * @generated from protobuf message sonrio.motor.service.v1.Payload
 */
export interface Payload {
    /**
     * @generated from protobuf field: repeated sonrio.motor.service.v1.Payload.Item items = 1;
     */
    items: Payload_Item[]; // Payload Items
    /**
     * @generated from protobuf field: sonrio.common.v1.Peer owner = 2;
     */
    owner?: Peer; // PROFILE: General Sender Info
    /**
     * @generated from protobuf field: int64 size = 3;
     */
    size: string; // Payload Size in Bytes
    /**
     * @generated from protobuf field: int64 created_at = 4;
     */
    createdAt: string; // Payload Creation Time in Seconds
}
/**
 * Item in Payload
 *
 * @generated from protobuf message sonrio.motor.service.v1.Payload.Item
 */
export interface Payload_Item {
    /**
     * @generated from protobuf field: sonrio.motor.service.v1.MIME mime = 1;
     */
    mime?: MIME; // MIME of the Item
    /**
     * @generated from protobuf field: int64 size = 2;
     */
    size: string; // Size of the Item in Bytes
    /**
     * @generated from protobuf oneof: data
     */
    data: {
        oneofKind: "file";
        /**
         * @generated from protobuf field: sonrio.motor.service.v1.FileItem file = 3;
         */
        file: FileItem; // FILE: File Item
    } | {
        oneofKind: "url";
        /**
         * @generated from protobuf field: string url = 4;
         */
        url: string; // URL: Url Item
    } | {
        oneofKind: "message";
        /**
         * @generated from protobuf field: string message = 5;
         */
        message: string; // MESSAGE: Message Item
    } | {
        oneofKind: undefined;
    };
    /**
     * Thumbnail of the Item
     *
     * @generated from protobuf field: sonrio.motor.service.v1.Thumbnail thumbnail = 6;
     */
    thumbnail?: Thumbnail; // Thumbnail of the Item
}
/**
 * SupplyItem is an item supplied to be a payload
 *
 * @generated from protobuf message sonrio.motor.service.v1.SupplyItem
 */
export interface SupplyItem {
    /**
     * @generated from protobuf field: string path = 1;
     */
    path: string; // Supply Path
    /**
     * @generated from protobuf field: bytes thumbnail = 2;
     */
    thumbnail: Uint8Array; // Supply Path of the Thumbnail
}
/**
 * Thumbnail of File
 *
 * @generated from protobuf message sonrio.motor.service.v1.Thumbnail
 */
export interface Thumbnail {
    /**
     * @generated from protobuf field: bytes buffer = 1;
     */
    buffer: Uint8Array; // Thumbnail Buffer
    /**
     * @generated from protobuf field: sonrio.motor.service.v1.MIME mime = 2;
     */
    mime?: MIME; // Mime Type
}
/**
 * @generated from protobuf message sonrio.motor.service.v1.Session
 */
export interface Session {
    /**
     * @generated from protobuf field: sonrio.motor.service.v1.Direction direction = 1;
     */
    direction: Direction;
    /**
     * @generated from protobuf field: sonrio.common.v1.Peer from = 2;
     */
    from?: Peer;
    /**
     * @generated from protobuf field: sonrio.common.v1.Peer to = 3;
     */
    to?: Peer;
    /**
     * @generated from protobuf field: sonrio.motor.service.v1.Payload payload = 4;
     */
    payload?: Payload;
    /**
     * @generated from protobuf field: int64 last_updated = 5;
     */
    lastUpdated: string;
    /**
     * @generated from protobuf field: repeated sonrio.motor.service.v1.SessionItem items = 6;
     */
    items: SessionItem[];
    /**
     * @generated from protobuf field: int32 current_index = 7;
     */
    currentIndex: number;
    /**
     * @generated from protobuf field: map<int32, bool> results = 8;
     */
    results: {
        [key: number]: boolean;
    };
}
/**
 * @generated from protobuf message sonrio.motor.service.v1.SessionItem
 */
export interface SessionItem {
    /**
     * @generated from protobuf field: int32 index = 1;
     */
    index: number;
    /**
     * @generated from protobuf field: int32 count = 2;
     */
    count: number;
    /**
     * @generated from protobuf field: sonrio.motor.service.v1.FileItem item = 3;
     */
    item?: FileItem;
    /**
     * @generated from protobuf field: int64 written = 4;
     */
    written: string;
    /**
     * @generated from protobuf field: int64 size = 5;
     */
    size: string;
    /**
     * @generated from protobuf field: int64 total_size = 6;
     */
    totalSize: string;
    /**
     * @generated from protobuf field: sonrio.motor.service.v1.Direction direction = 7;
     */
    direction: Direction;
    /**
     * @generated from protobuf field: string path = 8;
     */
    path: string;
}
/**
 * @generated from protobuf message sonrio.motor.service.v1.SessionPayload
 */
export interface SessionPayload {
    /**
     * @generated from protobuf field: sonrio.motor.service.v1.Payload payload = 1;
     */
    payload?: Payload;
    /**
     * @generated from protobuf field: sonrio.motor.service.v1.Direction direction = 2;
     */
    direction: Direction;
}
/**
 * Direction is the direction of a stream.
 *
 * @generated from protobuf enum sonrio.motor.service.v1.Direction
 */
export enum Direction {
    /**
     * Unspecified is the default value.
     *
     * @generated from protobuf enum value: DIRECTION_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Incoming is the direction of an incoming stream.
     *
     * @generated from protobuf enum value: DIRECTION_INCOMING = 1;
     */
    INCOMING = 1,
    /**
     * Outgoing is the direction of an outgoing stream.
     *
     * @generated from protobuf enum value: DIRECTION_OUTGOING = 2;
     */
    OUTGOING = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class MIME$Type extends MessageType<MIME> {
    constructor() {
        super("sonrio.motor.service.v1.MIME", [
            { no: 1, name: "type", kind: "enum", T: () => ["sonrio.motor.service.v1.MIME.Type", MIME_Type, "TYPE_"] },
            { no: 2, name: "subtype", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MIME>): MIME {
        const message = { type: 0, subtype: "", value: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MIME>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MIME): MIME {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sonrio.motor.service.v1.MIME.Type type */ 1:
                    message.type = reader.int32();
                    break;
                case /* string subtype */ 2:
                    message.subtype = reader.string();
                    break;
                case /* string value */ 3:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MIME, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sonrio.motor.service.v1.MIME.Type type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* string subtype = 2; */
        if (message.subtype !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subtype);
        /* string value = 3; */
        if (message.value !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.motor.service.v1.MIME
 */
export const MIME = new MIME$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FileItem$Type extends MessageType<FileItem> {
    constructor() {
        super("sonrio.motor.service.v1.FileItem", [
            { no: 1, name: "mime", kind: "message", T: () => MIME },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "size", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 5, name: "thumbnail", kind: "message", T: () => Thumbnail },
            { no: 6, name: "last_modified", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<FileItem>): FileItem {
        const message = { name: "", path: "", size: "0", lastModified: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FileItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FileItem): FileItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sonrio.motor.service.v1.MIME mime */ 1:
                    message.mime = MIME.internalBinaryRead(reader, reader.uint32(), options, message.mime);
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string path */ 3:
                    message.path = reader.string();
                    break;
                case /* int64 size */ 4:
                    message.size = reader.int64().toString();
                    break;
                case /* sonrio.motor.service.v1.Thumbnail thumbnail */ 5:
                    message.thumbnail = Thumbnail.internalBinaryRead(reader, reader.uint32(), options, message.thumbnail);
                    break;
                case /* int64 last_modified */ 6:
                    message.lastModified = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FileItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sonrio.motor.service.v1.MIME mime = 1; */
        if (message.mime)
            MIME.internalBinaryWrite(message.mime, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string path = 3; */
        if (message.path !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.path);
        /* int64 size = 4; */
        if (message.size !== "0")
            writer.tag(4, WireType.Varint).int64(message.size);
        /* sonrio.motor.service.v1.Thumbnail thumbnail = 5; */
        if (message.thumbnail)
            Thumbnail.internalBinaryWrite(message.thumbnail, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* int64 last_modified = 6; */
        if (message.lastModified !== "0")
            writer.tag(6, WireType.Varint).int64(message.lastModified);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.motor.service.v1.FileItem
 */
export const FileItem = new FileItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Payload$Type extends MessageType<Payload> {
    constructor() {
        super("sonrio.motor.service.v1.Payload", [
            { no: 1, name: "items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Payload_Item },
            { no: 2, name: "owner", kind: "message", T: () => Peer },
            { no: 3, name: "size", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 4, name: "created_at", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<Payload>): Payload {
        const message = { items: [], size: "0", createdAt: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Payload>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Payload): Payload {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated sonrio.motor.service.v1.Payload.Item items */ 1:
                    message.items.push(Payload_Item.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* sonrio.common.v1.Peer owner */ 2:
                    message.owner = Peer.internalBinaryRead(reader, reader.uint32(), options, message.owner);
                    break;
                case /* int64 size */ 3:
                    message.size = reader.int64().toString();
                    break;
                case /* int64 created_at */ 4:
                    message.createdAt = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Payload, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated sonrio.motor.service.v1.Payload.Item items = 1; */
        for (let i = 0; i < message.items.length; i++)
            Payload_Item.internalBinaryWrite(message.items[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* sonrio.common.v1.Peer owner = 2; */
        if (message.owner)
            Peer.internalBinaryWrite(message.owner, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int64 size = 3; */
        if (message.size !== "0")
            writer.tag(3, WireType.Varint).int64(message.size);
        /* int64 created_at = 4; */
        if (message.createdAt !== "0")
            writer.tag(4, WireType.Varint).int64(message.createdAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.motor.service.v1.Payload
 */
export const Payload = new Payload$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Payload_Item$Type extends MessageType<Payload_Item> {
    constructor() {
        super("sonrio.motor.service.v1.Payload.Item", [
            { no: 1, name: "mime", kind: "message", T: () => MIME },
            { no: 2, name: "size", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 3, name: "file", kind: "message", oneof: "data", T: () => FileItem },
            { no: 4, name: "url", kind: "scalar", oneof: "data", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "message", kind: "scalar", oneof: "data", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "thumbnail", kind: "message", T: () => Thumbnail }
        ]);
    }
    create(value?: PartialMessage<Payload_Item>): Payload_Item {
        const message = { size: "0", data: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Payload_Item>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Payload_Item): Payload_Item {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sonrio.motor.service.v1.MIME mime */ 1:
                    message.mime = MIME.internalBinaryRead(reader, reader.uint32(), options, message.mime);
                    break;
                case /* int64 size */ 2:
                    message.size = reader.int64().toString();
                    break;
                case /* sonrio.motor.service.v1.FileItem file */ 3:
                    message.data = {
                        oneofKind: "file",
                        file: FileItem.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).file)
                    };
                    break;
                case /* string url */ 4:
                    message.data = {
                        oneofKind: "url",
                        url: reader.string()
                    };
                    break;
                case /* string message */ 5:
                    message.data = {
                        oneofKind: "message",
                        message: reader.string()
                    };
                    break;
                case /* sonrio.motor.service.v1.Thumbnail thumbnail */ 6:
                    message.thumbnail = Thumbnail.internalBinaryRead(reader, reader.uint32(), options, message.thumbnail);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Payload_Item, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sonrio.motor.service.v1.MIME mime = 1; */
        if (message.mime)
            MIME.internalBinaryWrite(message.mime, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int64 size = 2; */
        if (message.size !== "0")
            writer.tag(2, WireType.Varint).int64(message.size);
        /* sonrio.motor.service.v1.FileItem file = 3; */
        if (message.data.oneofKind === "file")
            FileItem.internalBinaryWrite(message.data.file, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string url = 4; */
        if (message.data.oneofKind === "url")
            writer.tag(4, WireType.LengthDelimited).string(message.data.url);
        /* string message = 5; */
        if (message.data.oneofKind === "message")
            writer.tag(5, WireType.LengthDelimited).string(message.data.message);
        /* sonrio.motor.service.v1.Thumbnail thumbnail = 6; */
        if (message.thumbnail)
            Thumbnail.internalBinaryWrite(message.thumbnail, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.motor.service.v1.Payload.Item
 */
export const Payload_Item = new Payload_Item$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SupplyItem$Type extends MessageType<SupplyItem> {
    constructor() {
        super("sonrio.motor.service.v1.SupplyItem", [
            { no: 1, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "thumbnail", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SupplyItem>): SupplyItem {
        const message = { path: "", thumbnail: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SupplyItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SupplyItem): SupplyItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string path */ 1:
                    message.path = reader.string();
                    break;
                case /* bytes thumbnail */ 2:
                    message.thumbnail = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SupplyItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string path = 1; */
        if (message.path !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.path);
        /* bytes thumbnail = 2; */
        if (message.thumbnail.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.thumbnail);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.motor.service.v1.SupplyItem
 */
export const SupplyItem = new SupplyItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Thumbnail$Type extends MessageType<Thumbnail> {
    constructor() {
        super("sonrio.motor.service.v1.Thumbnail", [
            { no: 1, name: "buffer", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "mime", kind: "message", T: () => MIME }
        ]);
    }
    create(value?: PartialMessage<Thumbnail>): Thumbnail {
        const message = { buffer: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Thumbnail>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Thumbnail): Thumbnail {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes buffer */ 1:
                    message.buffer = reader.bytes();
                    break;
                case /* sonrio.motor.service.v1.MIME mime */ 2:
                    message.mime = MIME.internalBinaryRead(reader, reader.uint32(), options, message.mime);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Thumbnail, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes buffer = 1; */
        if (message.buffer.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.buffer);
        /* sonrio.motor.service.v1.MIME mime = 2; */
        if (message.mime)
            MIME.internalBinaryWrite(message.mime, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.motor.service.v1.Thumbnail
 */
export const Thumbnail = new Thumbnail$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Session$Type extends MessageType<Session> {
    constructor() {
        super("sonrio.motor.service.v1.Session", [
            { no: 1, name: "direction", kind: "enum", T: () => ["sonrio.motor.service.v1.Direction", Direction, "DIRECTION_"] },
            { no: 2, name: "from", kind: "message", T: () => Peer },
            { no: 3, name: "to", kind: "message", T: () => Peer },
            { no: 4, name: "payload", kind: "message", T: () => Payload },
            { no: 5, name: "last_updated", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 6, name: "items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SessionItem },
            { no: 7, name: "current_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "results", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 8 /*ScalarType.BOOL*/ } }
        ]);
    }
    create(value?: PartialMessage<Session>): Session {
        const message = { direction: 0, lastUpdated: "0", items: [], currentIndex: 0, results: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Session>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Session): Session {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sonrio.motor.service.v1.Direction direction */ 1:
                    message.direction = reader.int32();
                    break;
                case /* sonrio.common.v1.Peer from */ 2:
                    message.from = Peer.internalBinaryRead(reader, reader.uint32(), options, message.from);
                    break;
                case /* sonrio.common.v1.Peer to */ 3:
                    message.to = Peer.internalBinaryRead(reader, reader.uint32(), options, message.to);
                    break;
                case /* sonrio.motor.service.v1.Payload payload */ 4:
                    message.payload = Payload.internalBinaryRead(reader, reader.uint32(), options, message.payload);
                    break;
                case /* int64 last_updated */ 5:
                    message.lastUpdated = reader.int64().toString();
                    break;
                case /* repeated sonrio.motor.service.v1.SessionItem items */ 6:
                    message.items.push(SessionItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 current_index */ 7:
                    message.currentIndex = reader.int32();
                    break;
                case /* map<int32, bool> results */ 8:
                    this.binaryReadMap8(message.results, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap8(map: Session["results"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Session["results"] | undefined, val: Session["results"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.bool();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field sonrio.motor.service.v1.Session.results");
            }
        }
        map[key ?? 0] = val ?? false;
    }
    internalBinaryWrite(message: Session, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sonrio.motor.service.v1.Direction direction = 1; */
        if (message.direction !== 0)
            writer.tag(1, WireType.Varint).int32(message.direction);
        /* sonrio.common.v1.Peer from = 2; */
        if (message.from)
            Peer.internalBinaryWrite(message.from, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* sonrio.common.v1.Peer to = 3; */
        if (message.to)
            Peer.internalBinaryWrite(message.to, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* sonrio.motor.service.v1.Payload payload = 4; */
        if (message.payload)
            Payload.internalBinaryWrite(message.payload, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* int64 last_updated = 5; */
        if (message.lastUpdated !== "0")
            writer.tag(5, WireType.Varint).int64(message.lastUpdated);
        /* repeated sonrio.motor.service.v1.SessionItem items = 6; */
        for (let i = 0; i < message.items.length; i++)
            SessionItem.internalBinaryWrite(message.items[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* int32 current_index = 7; */
        if (message.currentIndex !== 0)
            writer.tag(7, WireType.Varint).int32(message.currentIndex);
        /* map<int32, bool> results = 8; */
        for (let k of Object.keys(message.results))
            writer.tag(8, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Varint).bool(message.results[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.motor.service.v1.Session
 */
export const Session = new Session$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SessionItem$Type extends MessageType<SessionItem> {
    constructor() {
        super("sonrio.motor.service.v1.SessionItem", [
            { no: 1, name: "index", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "item", kind: "message", T: () => FileItem },
            { no: 4, name: "written", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 5, name: "size", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 6, name: "total_size", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 7, name: "direction", kind: "enum", T: () => ["sonrio.motor.service.v1.Direction", Direction, "DIRECTION_"] },
            { no: 8, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SessionItem>): SessionItem {
        const message = { index: 0, count: 0, written: "0", size: "0", totalSize: "0", direction: 0, path: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SessionItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SessionItem): SessionItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 index */ 1:
                    message.index = reader.int32();
                    break;
                case /* int32 count */ 2:
                    message.count = reader.int32();
                    break;
                case /* sonrio.motor.service.v1.FileItem item */ 3:
                    message.item = FileItem.internalBinaryRead(reader, reader.uint32(), options, message.item);
                    break;
                case /* int64 written */ 4:
                    message.written = reader.int64().toString();
                    break;
                case /* int64 size */ 5:
                    message.size = reader.int64().toString();
                    break;
                case /* int64 total_size */ 6:
                    message.totalSize = reader.int64().toString();
                    break;
                case /* sonrio.motor.service.v1.Direction direction */ 7:
                    message.direction = reader.int32();
                    break;
                case /* string path */ 8:
                    message.path = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SessionItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 index = 1; */
        if (message.index !== 0)
            writer.tag(1, WireType.Varint).int32(message.index);
        /* int32 count = 2; */
        if (message.count !== 0)
            writer.tag(2, WireType.Varint).int32(message.count);
        /* sonrio.motor.service.v1.FileItem item = 3; */
        if (message.item)
            FileItem.internalBinaryWrite(message.item, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* int64 written = 4; */
        if (message.written !== "0")
            writer.tag(4, WireType.Varint).int64(message.written);
        /* int64 size = 5; */
        if (message.size !== "0")
            writer.tag(5, WireType.Varint).int64(message.size);
        /* int64 total_size = 6; */
        if (message.totalSize !== "0")
            writer.tag(6, WireType.Varint).int64(message.totalSize);
        /* sonrio.motor.service.v1.Direction direction = 7; */
        if (message.direction !== 0)
            writer.tag(7, WireType.Varint).int32(message.direction);
        /* string path = 8; */
        if (message.path !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.path);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.motor.service.v1.SessionItem
 */
export const SessionItem = new SessionItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SessionPayload$Type extends MessageType<SessionPayload> {
    constructor() {
        super("sonrio.motor.service.v1.SessionPayload", [
            { no: 1, name: "payload", kind: "message", T: () => Payload },
            { no: 2, name: "direction", kind: "enum", T: () => ["sonrio.motor.service.v1.Direction", Direction, "DIRECTION_"] }
        ]);
    }
    create(value?: PartialMessage<SessionPayload>): SessionPayload {
        const message = { direction: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SessionPayload>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SessionPayload): SessionPayload {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sonrio.motor.service.v1.Payload payload */ 1:
                    message.payload = Payload.internalBinaryRead(reader, reader.uint32(), options, message.payload);
                    break;
                case /* sonrio.motor.service.v1.Direction direction */ 2:
                    message.direction = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SessionPayload, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sonrio.motor.service.v1.Payload payload = 1; */
        if (message.payload)
            Payload.internalBinaryWrite(message.payload, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* sonrio.motor.service.v1.Direction direction = 2; */
        if (message.direction !== 0)
            writer.tag(2, WireType.Varint).int32(message.direction);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sonrio.motor.service.v1.SessionPayload
 */
export const SessionPayload = new SessionPayload$Type();
